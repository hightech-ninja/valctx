package gen

import (
	"context"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"io"
	"net/url"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

type Field struct {
	FieldName string
	FieldType string
	KeyName   string

	// not used in the go template
	pkg string
}

func (f *Field) SetPackage(pkg string) {
	f.pkg = pkg
}

func (f *Field) Validate() error {
	if !isValidIdentifier(f.FieldName) {
		return errors.New("invalid name")
	}
	if !isValidIdentifier(f.KeyName) {
		return errors.New("invalid key name")
	}

	if f.pkg != "" { // exported field
		if !isValidImportPath(f.pkg) {
			return errors.New("invalid package name")
		}
		if !isValidImportedStruct(f.FieldType) {
			return errors.New("invalid type")
		}
	} else { // built-in field
		tr, err := parser.ParseExpr(f.FieldType)
		if err != nil {
			return fmt.Errorf("go parser: %v", err)
		}
		// printExpr(tr)
		if !isBuiltInType(tr) {
			return errors.New("invalid type")
		}
	}
	return nil
}

func isExported(name string) bool {
	if name == "" {
		return false
	}
	first, _ := utf8.DecodeRuneInString(name)
	return unicode.IsUpper(first)
}

func isValidImportedStruct(s string) bool {
	parts := strings.Split(s, ".")
	if len(parts) != 2 {
		return false
	}
	pkgName, typeName := parts[0], parts[1]
	return isValidIdentifier(pkgName) && isValidIdentifier(typeName) && isExported(typeName)
}

func isValidImportPath(path string) bool {
	// https://golang.org/ref/spec#Import_declarations
	if path == "" {
		return false
	}
	if strings.Contains(path, " ") {
		return false
	}
	_, err := url.ParseRequestURI("https://" + path)
	if err != nil {
		return false
	}
	if strings.Contains(path, "\\") {
		return false
	}
	return true
}

func isValidIdentifier(name string) bool {
	if name == "" {
		return false
	}
	// https://go.dev/ref/spec#Identifiers
	for i, r := range name {
		if i == 0 && !unicode.IsLetter(r) && r != '_' {
			return false
		}
		if i > 0 && !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '_' {
			return false
		}
	}
	return true
}

func isBuiltInType(expr ast.Expr) bool {
	switch t := expr.(type) {
	default:
		return false
	case *ast.Ident:
		switch t.Name {
		case "bool", "string", "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
			"byte", "rune", "float32", "float64", "complex64", "complex128":
			return true
		default:
			return false
		}
	case *ast.InterfaceType:
		return len(t.Methods.List) == 0
	case *ast.ArrayType:
		return isBuiltInType(t.Elt)
	case *ast.MapType:
		return isBuiltInType(t.Key) && isBuiltInType(t.Value)
	case *ast.ChanType:
		return isBuiltInType(t.Value)
	case *ast.StarExpr:
		return isBuiltInType(t.X)
	}
}

// func printExpr(tr ast.Expr) {
// 	fmt.Println("-------------------")
// 	fs := token.NewFileSet()
// 	_ = ast.Print(fs, tr)
// 	fmt.Println("-------------------")
// }

type Package struct {
	PackageName    string
	ImportPackages []string
	Version        string
}

func (p *Package) Validate() error {
	if !isValidIdentifier(p.PackageName) {
		return errors.New("invalid package name")
	}
	for _, path := range p.ImportPackages {
		if !isValidImportPath(path) {
			return errors.New("invalid import path")
		}
	}
	return nil
}

func Generate(ctx context.Context, out io.Writer, pkg Package, fields []Field) error {
	var (
		pkgTemplate = template.Must(template.New("package").Parse(
			`// Code generated by valctx {{.Version}}. DO NOT EDIT.

package {{.PackageName}}
{{ if .ImportPackages }}
import (
    {{- range .ImportPackages }}
    "{{.}}"
    {{- end }}
)
{{ end }}`))
		castedFieldTemplate = template.Must(template.New("casted-field").Parse(`
type {{.KeyName}} struct{}

// Get {{.FieldName}} retrieves the {{.FieldName}} from the context.
func Get{{.FieldName}}(ctx context.Context) ({{.FieldType}}, bool) {
    v, ok := ctx.Value({{.KeyName}}{}).({{.FieldType}})
    return v, ok
}

// Set{{.FieldName}} sets the {{.FieldName}} in the context.
func Set{{.FieldName}}(ctx context.Context, v {{.FieldType}}) context.Context {
    return context.WithValue(ctx, {{.KeyName}}{}, v)
}
`))
		anyFieldTemplate = template.Must(template.New("any-field").Parse(`
type {{.KeyName}} struct{}

// Get {{.FieldName}} retrieves the {{.FieldName}} from the context.
func Get{{.FieldName}}(ctx context.Context) interface{} {
    v := ctx.Value({{.KeyName}}{})
    return v
}

// Set{{.FieldName}} sets the {{.FieldName}} in the context.
func Set{{.FieldName}}(ctx context.Context, v interface{}) context.Context {
    return context.WithValue(ctx, {{.KeyName}}{}, v)
}
`))
	)
	err := pkgTemplate.Execute(out, pkg)
	if err != nil {
		return fmt.Errorf("bootstrap package: %v", err)
	}
	for _, field := range fields {
		tmpl := castedFieldTemplate
		if field.FieldType == "interface{}" {
			tmpl = anyFieldTemplate
		}
		err = tmpl.Execute(out, &field)
		if err != nil {
			return fmt.Errorf("bootstrap field %q: %v", field.FieldName, err)
		}

		if ctx.Err() != nil {
			return ctx.Err()
		}
	}
	return nil
}
